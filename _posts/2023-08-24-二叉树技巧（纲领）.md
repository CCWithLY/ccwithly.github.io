---
layout:     post
title:      二叉树技巧总结
subtitle:   v2.5版
date:       2023-08-24
author:     CCWithLY
header-img: img/believe.jpg
catalog: true
tags:
    - 算法学习
---

### 前言
递归解法应该是最简单，最容易理解的才对，行云流水地写递归代码是学好算法的基本功，而二叉树相关的题目就是最练习递归基本功，最练习框架思维的。

### 二叉树解题思维

- **是否可以通过遍历一遍二叉树得到答案？** 如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。
- **是否可以定义一个递归函数**，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，都需要思考：  

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？** 其他的节点不用操心，递归函数会帮你在所有节点上执行相同的操作。

### 二叉树的重要性

经典算法「[快速排序](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/kuai-su-pa-39aa2/)」和「[归并排序](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/gui-bing-p-1387f/)」，有什么特点，跟二叉树又有什么关系？  

**快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后续遍历**  

算法思想和代码框架：  

**快速排序**：若要对nums[lo..hi]进行排序，我们先找一个分界点p，通过交换元素使得nums[lo..p-1]都小于等于nums[p]，且nums[p+1..hi]都大于nums[p]，然后递归地去nums[lo..p-1]和nums[p+1..hi]中寻找新的分界点，最后整个数组就被排序了。

```C++
//快速排序代码框架
void sort(int[] nums, int lo, int hi) {
    /****** 前序遍历位置 ******/
    // 通过交换元素构建分界点 p
    int p = partition(nums, lo, hi);
    /************************/

    sort(nums, lo, p - 1);
    sort(nums, p + 1, hi);
}
``` 
先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？  

**归并排序**：若要对nums[lo..hi]进行排序，我们先对nums[lo..mid]排序，再对nums[mid+1..hi]排序，最后把这两个有序的子数组合并，整个数组就排好序了。

```C++
//归并排序代码框架
void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    sort(nums, lo, mid);
    sort(nums, mid + 1, hi);

    /****** 后序遍历位置 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
    /************************/
}
``` 
先对左右子数组排序，然后合并（类似合并有序链表的逻辑），这就是二叉树的后序遍历框架。另外，这不就是传说中的分治算法嘛。  

### 二叉树与递归

先不管所谓前中后序，单看二叉树框架的 traverse 函数在做什么事情？  

其实它就是一个能够遍历二叉树所有节点的一个函数，和遍历数组或者链表本质上没有区别。  

单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，**由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式**。只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。  

> 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

### 

### 递归算法秘诀

**写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要试图跳入递归。**

**写树相关的算法，简单说就是，先搞清楚当前root节点该做什么，然后根据函数定义递归调用子节点，递归调用会让孩子节点做相同的事情。**

### 算法实践

1. 翻转二叉树（LeetCode226.简单）
```C++
// 将整棵树的节点翻转
TreeNode invertTree(TreeNode root) {
    // base case
    if (root == null) {
        return null;
    }

    /**** 前序遍历位置 ****/
    // root 节点需要交换它的左右子节点
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // 让左右子节点继续翻转它们的子节点
    invertTree(root.left);
    invertTree(root.right);

    return root;
}
```
**通过观察，发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。**

> 难点：如何把题目的要求细化成每个节点需要做的事情。

2. 填充二叉树节点的右侧指针（LeetCode116，中等）

**主要问题**：如果只依赖一个节点的话，肯定是没办法连接「跨父节点」的两个相邻节点的  
**解决方案**：做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」
```C++
// 主函数
Node connect(Node root) {
    if (root == null) return null;
    connectTwoNode(root.left, root.right);
    return root;
}

// 定义：输入两个节点，将它俩连接起来
void connectTwoNode(Node node1, Node node2) {
    if (node1 == null || node2 == null) {
        return;
    }
    /**** 前序遍历位置 ****/
    // 将传入的两个节点连接
    node1.next = node2;

    // 连接相同父节点的两个子节点
    connectTwoNode(node1.left, node1.right);
    connectTwoNode(node2.left, node2.right);
    // 连接跨越父节点的两个子节点
    connectTwoNode(node1.right, node2.left);
}
```

3. 将二叉树展开为链表（LeetCode114，中等）

**主要问题**：给flatten函数输入一个节点root，那么以root为根的二叉树就会被拉平为一条链表。  
**解决方案**：如何按题目要求把一棵树拉平成一条链表？
- 将root的左子树和右子树拉平。
- 将root的右子树接到左子树下方，然后将整个左子树作为右子树。

```C++
// 定义：将以 root 为根的树拉平为链表
void flatten(TreeNode root) {
    // base case
    if (root == null) return;

    flatten(root.left);
    flatten(root.right);

    /**** 后序遍历位置 ****/
    // 1、左右子树已经被拉平成一条链表
    TreeNode left = root.left;
    TreeNode right = root.right;

    // 2、将左子树作为右子树
    root.left = null;
    root.right = left;

    // 3、将原先的右子树接到当前右子树的末端
    TreeNode p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
}
```
**只要知道flatten的定义如此，相信这个定义，让root做它该做的事情，然后flatten函数就会按照定义工作。**

### 后序遍历的特殊之处

说后序位置之前，先简单说下中序和前序。  

中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。  

前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。  

可以发现，**前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的**。  

这意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。  

一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。  

**看下后序位置是如何在实际的题目中发挥作用的**：  

LeetCode543，二叉树的直径，简单  

所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度。最长「直径」并不一定要穿过根结点。**每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和**。  

思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的「直径」，最后把所有「直径」求个最大值即可。  

前序位置无法获取子树信息，所以只能让每个节点调用 maxDepth 函数去算子树的深度，所以运行时间很长。  

优化：应该把计算「直径」的逻辑放在后序位置，准确说应该是放在 maxDepth 的后序位置，因为 maxDepth 的后序位置是知道左右子树的最大深度的。
```C++
class Solution {
    // 记录最大直径的长度
    int maxDiameter = 0;

public:
    int diameterOfBinaryTree(TreeNode* root) {
        maxDepth(root);
        return maxDiameter;
    }

    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        // 后序位置，顺便计算最大直径
        int myDiameter = leftMax + rightMax;
        maxDiameter = max(maxDiameter, myDiameter);

        return 1 + max(leftMax, rightMax);
    }
};
```

### 以树的视角看动归/回溯/DFS算法的区别和联系

- 动态规划/回溯算法就是二叉树算法两种不同思路的表现形式
- DFS 算法和回溯算法非常类似，只是在细节上有所区别

> 差别就是「做选择」和「撤销选择」到底在 for 循环外面还是里面的区别，DFS 算法在外面，回溯算法在里面。

**动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同**：  

- 动态规划算法属于分解问题的思路，它的关注点在整棵「子树」
- 回溯算法属于遍历的思路，它的关注点在节点间的「树枝」。
- DFS 算法属于遍历的思路，它的关注点在单个「节点」。

> 动态规划分解问题的思路，它的着眼点永远是结构相同的整个子问题，类比到二叉树上就是「子树」
> 回溯算法遍历的思路，它的着眼点永远是在节点之间移动的过程，类比到二叉树上就是「树枝」
> DFS 算法遍历的思路，它的着眼点永远是在单一的节点上，类比到二叉树上就是处理每个「节点」。

### 总结

递归算法的关键要明确函数的定义，相信这个定义，而不要跳进递归细节。  

写二叉树的算法题，都是基于递归框架的，我们先要搞清楚root节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架。  

二叉树题目的难点在于如何通过题目的要求思考出每一个节点需要做什么，这个只能通过多刷题进行练习了。  

**一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。**